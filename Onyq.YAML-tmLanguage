# [PackageDev] target_format: plist, ext: tmLanguage
comment: "\n\tTODO: unresolved issues\n\n\ttext:\n\t\"p << end\n\tprint me!\n\tend\"\
  \n\tsymptoms:\n\tnot recognized as a heredoc\n\tsolution:\n\tthere is no way to\
  \ distinguish perfectly between the << operator and the start\n\tof a heredoc. Currently,\
  \ we require assignment to recognize a heredoc. More\n\trefinement is possible.\n\
  \t\u2022 Heredocs with indented terminators (<<-) are always distinguishable, however.\n\
  \t\u2022 Nested heredocs are not really supportable at present\n\n\ttext:\n\tprint\
  \ <<-'THERE'\n\tThis is single quoted.\n\tThe above used #{Time.now}\n\tTHERE\n\t\
  symtoms:\n\tFrom Programming Ruby p306; should be a non-interpolated heredoc.\n\n\
  \ttext:\n\t\"a\\332a\"\n\tsymptoms:\n\t'\\332' is not recognized as slash3.. which\
  \ should be octal 332.\n\tsolution:\n\tplain regexp.. should be easy.\n\n    text:\n\
  \    val?(a):p(b)\n    val?'a':'b'\n    symptoms:\n    ':p' is recognized as a symbol..\
  \ its 2 things ':' and 'p'.\n    :'b' has same problem.\n    solution:\n    ternary\
  \ operator rule, precedence stuff, symbol rule.\n    but also consider 'a.b?(:c)'\
  \ ??\n"
name: Crystal
scopeName: source.onyx
fileTypes: [cr]
uuid: 3492DA0A-255E-48FD-9C64-8D8B073F8BF7

patterns:
- name: meta.class.onyx
  match: "(?x)\n\t\t\t\t^\n\t\t\t\t\\s*\n\t\t\t\t(abstract)?\n\t\t\t\t\\s*\n\t\t\t\
    \t(class)\n\t\t\t\t\\s+\n\t\t\t\t(\n\t\t\t\t\t(\n\t\t\t\t\t\t[.A-Z_:\\x{80}-\\\
    x{10FFFF}][.\\w:\\x{80}-\\x{10FFFF}]*\n\t\t\t\t\t\t(\\(([,\\s.a-zA-Z0-9_:\\x{80}-\\\
    x{10FFFF}]+)\\))?\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\\s*(<)\\s*\n\t\t\t\t\t\t\t[.:A-Z\\\
    x{80}-\\x{10FFFF}][.:\\w\\x{80}-\\x{10FFFF}]*\n\t\t\t\t\t\t\t(\\(([.a-zA-Z0-9_:]+\\\
    s,)\\))?\n\t\t\t\t\t\t)?\n\t\t\t\t\t)|(\n\t\t\t\t\t\t(<<)\n\t\t\t\t\t\t\\s*\n\t\
    \t\t\t\t\t[.A-Z0-9_:\\x{80}-\\x{10FFFF}]+\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t"
  captures:
    '1': {name: keyword.control.class.onyx}
    '2': {name: keyword.control.class.onyx}
    '3': {name: entity.name.type.class.onyx}
    '5': {name: punctuation.separator.onyx}
    '6': {name: support.class.other.type-param.onyx}
    '7': {name: entity.other.inherited-class.onyx}
    '8': {name: punctuation.separator.onyx}
    '9': {name: punctuation.separator.onyx}
    '10': {name: support.class.other.type-param.onyx}
    '11': {name: punctuation.definition.variable.onyx}

- name: meta.module.onyx
  match: ^\s*(module)\s+(([A-Z\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*(::))?([A-Z\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*(::))?([A-Z\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*(::))*[A-Z\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*)
  captures:
    '1': {name: keyword.control.module.onyx}
    '2': {name: entity.name.type.module.onyx}
    '3': {name: entity.other.inherited-class.module.first.onyx}
    '4': {name: punctuation.separator.inheritance.onyx}
    '5': {name: entity.other.inherited-class.module.second.onyx}
    '6': {name: punctuation.separator.inheritance.onyx}
    '7': {name: entity.other.inherited-class.module.third.onyx}
    '8': {name: punctuation.separator.inheritance.onyx}

- name: meta.lib.onyx
  match: ^\s*(lib)\s+(([A-Z]\w*(::))?([A-Z]\w*(::))?([A-Z]\w*(::))*[A-Z]\w*)
  captures:
    '1': {name: keyword.control.lib.onyx}
    '2': {name: entity.name.type.lib.onyx}
    '3': {name: entity.other.inherited-class.lib.first.onyx}
    '4': {name: punctuation.separator.inheritance.onyx}
    '5': {name: entity.other.inherited-class.lib.second.onyx}
    '6': {name: punctuation.separator.inheritance.onyx}
    '7': {name: entity.other.inherited-class.lib.third.onyx}
    '8': {name: punctuation.separator.inheritance.onyx}

- comment: "else if is a common mistake carried over from other languages. it works\
    \ if you put in a second end, but it\u2019s never what you want."
  name: invalid.deprecated.onyx
  match: (?<!\.)\belse(\s)+if\b

- comment: "everything being a reserved word, not a value and needing a 'end' is a.."
  name: keyword.control.primary.onyx
  match: (?<!\.)\b(BEGIN|alias|as|begin|case|abstract|class|END|ensure|for|fun|if|ifdef|in|lib|module|of|out|rescue|struct|with|union|enum|macro|then|type|unless|until|while)\b(?![?!])

- comment: "everything being a reserved word, not a value and needing a 'end' is a.."
  name: keyword.control.secondary.onyx
  match: (?<!\.)\b(when|else|elsif)\b(?![?!])

- comment: Give the end keyword an additional scope
  name: keyword.control.secondary.end.onyx
  match: (?<!\.)\b(end)\b(?![?!])

- comment: contextual smart pair support for block parameters
  name: keyword.control.start-block.onyx
  match: (?<!\.)\bdo\b\s*

- comment: contextual smart pair support
  name: meta.syntax.onyx.start-block
  match: (?<=\{)(\s+)

- comment: " as above, just doesn't need a 'end' and does a logic operation"
  name: keyword.operator.logical.onyx
  match: (?<!\.)\b(and|not|or)\b

- comment: ' just as above but being not a logical operation'
  name: keyword.control.pseudo-method.onyx
  match: (?<!\.)\b(alias|alias_method|break|next|pointerof|typeof|sizeof|instance_sizeof|zredo|retry|return|super|undef|yield)\b(?![?!])|\bdefined\?|\bblock_given\?

- name: constant.language.onyx
  match: \b(nil|true|false)\b(?![?!])

- name: variable.language.onyx
  match: \b(__(FILE|LINE)__|self)\b(?![?!])

- comment: ' everything being a method but having a special function is a..'
  name: keyword.other.special-method.onyx
  match: \b(initialize|new|loop|include|extend|raise|getter|setter|property|private|protected|describe|it|with|delegate|def_hash|def_equals|def_equals_and_hash|forward_missing_to|record|assert_responds_to)\b[!?]?

- name: meta.require.onyx
  begin: \b(require|gem)\b
  end: $|(?=#)
  captures:
    '1': {name: keyword.other.special-method.onyx}
  patterns:
  - include: $self

- name: variable.other.readwrite.instance.onyx
  match: (@)[a-zA-Z_\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*[?!=]?
  captures:
    '1': {name: punctuation.definition.variable.onyx}

- name: variable.other.readwrite.class.onyx
  match: (@@)[a-zA-Z_\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*[?!=]?
  captures:
    '1': {name: punctuation.definition.variable.onyx}

- name: variable.other.readwrite.global.onyx
  match: (\$)[a-zA-Z_]\w*
  captures:
    '1': {name: punctuation.definition.variable.onyx}

- name: variable.other.readwrite.global.pre-defined.onyx
  match: (\$)(!|@|&|`|'|\+|\d+|~|=|/|\\|,|;|\.|<|>|_|\*|\$|\?|:|"|-[0adFiIlpv])
  captures:
    '1': {name: punctuation.definition.variable.onyx}

- name: meta.environment-variable.onyx
  begin: \b(ENV)\[
  beginCaptures:
    '1': {name: variable.other.constant.onyx}
  end: \]
  patterns:
  - include: $self

- name: support.class.onyx
  match: \b[A-Z\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*

- name: variable.other.constant.onyx
  match: \b[A-Z\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*\b

- comment: the method pattern comes from the symbol pattern, see there for a explaination
  name: meta.function.method.with-arguments.onyx
  contentName: variable.parameter.function.onyx
  begin: "(?x)\n\t\t\t         (?=def\\b)                                        \
    \              # an optimization to help Oniguruma fail fast\n\t\t\t         (?<=^|\\\
    s)(def)\\s+                                              # the def keyword\n\t\
    \t\t         ( (?>[a-zA-Z_\\x{80}-\\x{10FFFF}][\\x{80}-\\x{10FFFF}\\w]*(?>\\.|::))?\
    \                                   # a method name prefix\n\t\t\t           (?>[a-zA-Z_\\\
    x{80}-\\x{10FFFF}][\\x{80}-\\x{10FFFF}\\w]*(?>[?!]|=(?!>))?                  \
    \            # the method name\n\t\t\t           |===?|>[>=]?|<=>|<[<=]?|[%&`/\\\
    |]|\\*\\*?|=?~|[-+]@?|\\[\\]=?) )  # \u2026or an operator method\n\t\t\t     \
    \    \\s*(\\()                                                        # the openning\
    \ parenthesis for arguments\n\t\t\t        "
  beginCaptures:
    '1': {name: keyword.control.def.onyx}
    '2': {name: entity.name.function.onyx}
    '3': {name: punctuation.definition.parameters.onyx}
  end: \)(?=\s*(#.*)?$)
  endCaptures:
    '0': {name: punctuation.definition.parameters.onyx}
  patterns: []
- comment: same as the previous rule, but without parentheses around the arguments
  name: meta.function.method.with-arguments.onyx
  contentName: variable.parameter.function.onyx
  begin: "(?x)\n\t\t\t         (?=def\\b)                                        \
    \              # an optimization to help Oniguruma fail fast\n\t\t\t         (?<=^|\\\
    s)(def)\\s+                                              # the def keyword\n\t\
    \t\t         ( (?>[a-zA-Z_\\x{80}-\\x{10FFFF}][\\w\\x{80}-\\x{10FFFF}]*(?>\\.|::))?\
    \                                   # a method name prefix\n\t\t\t           (?>[a-zA-Z_\\\
    x{80}-\\x{10FFFF}][\\w\\x{80}-\\x{10FFFF}]*(?>[?!]|=(?!>))?                  \
    \            # the method name\n\t\t\t           |===?|>[>=]?|<=>|<[<=]?|[%&`/\\\
    |]|\\*\\*?|=?~|[-+]@?|\\[\\]=?) )  # \u2026or an operator method\n\t\t\t     \
    \    [ \\t]                                                          # the space\
    \ separating the arguments\n\t\t\t         (?=[ \\t]*[^\\s#;])               \
    \                               # make sure arguments and not a comment follow\n\
    \t\t\t        "
  beginCaptures:
    '1': {name: keyword.control.def.onyx}
    '2': {name: entity.name.function.onyx}
  end: $
  patterns: []
- comment: ' the optional name is just to catch the def also without a method-name'
  name: meta.function.method.without-arguments.onyx
  match: "(?x)\n\t\t\t         (?=def\\b)                                        \
    \                   # an optimization to help Oniguruma fail fast\n\t\t\t    \
    \     (?<=^|\\s)(def)\\b                                                    #\
    \ the def keyword\n\t\t\t         ( \\s+                                     \
    \                          # an optional group of whitespace followed by\u2026\
    \n\t\t\t           ( (?>[a-zA-Z_\\x{80}-\\x{10FFFF}][\\w\\x{80}-\\x{10FFFF}]*(?>\\\
    .|::))?                                      # a method name prefix\n\t\t\t  \
    \           (?>[a-zA-Z_\\x{80}-\\x{10FFFF}][\\w\\x{80}-\\x{10FFFF}]*(?>[?!]|=(?!>))?\
    \                                 # the method name\n\t\t\t             |===?|>[>=]?|<=>|<[<=]?|[%&`/\\\
    |]|\\*\\*?|=?~|[-+]@?|\\[\\]=?) ) )?  # \u2026or an operator method\n\t\t\t  \
    \      "
  captures:
    '1': {name: keyword.control.def.onyx}
    '3': {name: entity.name.function.onyx}
- name: constant.numeric.onyx
  match: \b(0[xX]\h(?>_?\h)*|\d(?>_?\d)*(\.(?![^[:space:][:digit:]])(?>_?\d)*)?([eE][-+]?\d(?>_?\d)*)?|0[bB][01]+)(_?(u8|u16|u32|u64|i8|i16|i32|i64|f32|f64))?\b
- name: constant.other.symbol.single-quoted.onyx
  begin: :'
  end: "'"
  captures:
    '0': {name: punctuation.definition.constant.onyx}
  patterns:
  - name: constant.character.escape.onyx
    match: \\['\\]
- name: constant.other.symbol.double-quoted.onyx
  begin: :"
  end: '"'
  captures:
    '0': {name: punctuation.definition.constant.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: Needs higher precidence than regular expressions.
  name: keyword.operator.assignment.augmented.onyx
  match: /=
- comment: single quoted string (does not allow interpolation)
  name: string.quoted.single.onyx
  begin: "'"
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: "'"
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - name: constant.character.escape.onyx
    match: \\'|\\\\
- comment: double quoted string (allows for interpolation)
  name: string.quoted.double.onyx
  begin: '"'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: '"'
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: execute string (allows for interpolation)
  name: string.interpolated.onyx
  begin: '`'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: '`'
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: execute string (allow for interpolation)
  name: string.interpolated.onyx
  begin: '%x\{'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \}
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
  - include: '#nest_curly_i'
- comment: execute string (allow for interpolation)
  name: string.interpolated.onyx
  begin: '%x\['
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \]
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
  - include: '#nest_brackets_i'
- comment: execute string (allow for interpolation)
  name: string.interpolated.onyx
  begin: '%x\<'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \>
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
  - include: '#nest_ltgt_i'
- comment: execute string (allow for interpolation)
  name: string.interpolated.onyx
  begin: '%x\('
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \)
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
  - include: '#nest_parens_i'
- comment: execute string (allow for interpolation)
  name: string.interpolated.onyx
  begin: '%x([^\w])'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \1
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: "regular expressions (normal)\n\t\t\twe only start a regexp if the character\
    \ before it (excluding whitespace)\n\t\t\tis what we think is before a regexp\n\
    \t\t\t"
  contentName: string.regexp.classic.onyx
  begin: "(?x)\n\t\t\t   (?:\n\t\t\t     ^                      # beginning of line\n\
    \t\t\t   | (?<=                   # or look-behind on:\n\t\t\t       [=>~(?:\\\
    [,|&;]\n\t\t\t     | [\\s;]if\\s\t\t\t# keywords\n\t\t\t     | [\\s;]elsif\\s\n\
    \t\t\t     | [\\s;]while\\s\n\t\t\t     | [\\s;]unless\\s\n\t\t\t     | [\\s;]when\\\
    s\n\t\t\t     | [\\s;]assert_match\\s\n\t\t\t     | [\\s;]or\\s\t\t\t# boolean\
    \ opperators\n\t\t\t     | [\\s;]and\\s\n\t\t\t     | [\\s;]not\\s\n\t\t\t   \
    \  | [\\s.]index\\s\t\t\t# methods\n\t\t\t     | [\\s.]scan\\s\n\t\t\t     | [\\\
    s.]sub\\s\n\t\t\t     | [\\s.]sub!\\s\n\t\t\t     | [\\s.]gsub\\s\n\t\t\t    \
    \ | [\\s.]gsub!\\s\n\t\t\t     | [\\s.]match\\s\n\t\t\t     )\n\t\t\t   | (?<=\
    \                  # or a look-behind with line anchor:\n\t\t\t        ^when\\\
    s            # duplication necessary due to limits of regex\n\t\t\t      | ^if\\\
    s\n\t\t\t      | ^elsif\\s\n\t\t\t      | ^while\\s\n\t\t\t      | ^unless\\s\n\
    \t\t\t      )\n\t\t\t   )\n\t\t\t   \\s*((/))(?![*+{}?])\n\t\t\t"
  end: ((/[eimnosux]*))
  captures:
    '1': {name: string.regexp.classic.onyx}
    '2': {name: punctuation.definition.string.onyx}
  patterns:
  - include: '#regex_sub'
- comment: regular expressions (literal)
  name: string.regexp.mod-r.onyx
  begin: '%r\{'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \}[eimnosux]*
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#regex_sub'
  - include: '#nest_curly_r'
- comment: regular expressions (literal)
  name: string.regexp.mod-r.onyx
  begin: '%r\['
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \][eimnosux]*
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#regex_sub'
  - include: '#nest_brackets_r'
- comment: regular expressions (literal)
  name: string.regexp.mod-r.onyx
  begin: '%r\('
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \)[eimnosux]*
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#regex_sub'
  - include: '#nest_parens_r'
- comment: regular expressions (literal)
  name: string.regexp.mod-r.onyx
  begin: '%r\<'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \>[eimnosux]*
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#regex_sub'
  - include: '#nest_ltgt_r'
- comment: regular expressions (literal)
  name: string.regexp.mod-r.onyx
  begin: '%r([^\w])'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \1[eimnosux]*
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#regex_sub'
- comment: literal capable of interpolation ()
  name: string.quoted.other.literal.upper.onyx
  begin: '%[QWSR]?\('
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \)
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
  - include: '#nest_parens_i'
- comment: literal capable of interpolation []
  name: string.quoted.other.literal.upper.onyx
  begin: '%[QWSR]?\['
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \]
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
  - include: '#nest_brackets_i'
- comment: literal capable of interpolation <>
  name: string.quoted.other.literal.upper.onyx
  begin: '%[QWSR]?\<'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \>
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
  - include: '#nest_ltgt_i'
- comment: literal capable of interpolation -- {}
  name: string.quoted.double.onyx.mod
  begin: '%[QWSR]?\{'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \}
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
  - include: '#nest_curly_i'
- comment: literal capable of interpolation -- wildcard
  name: string.quoted.other.literal.upper.onyx
  begin: '%[QWSR]([^\w])'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \1
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: literal incapable of interpolation -- ()
  name: string.quoted.other.literal.lower.onyx
  begin: '%[qws]\('
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \)
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - name: constant.character.escape.onyx
    match: \\\)|\\\\
  - include: '#nest_parens'
- comment: literal incapable of interpolation -- <>
  name: string.quoted.other.literal.lower.onyx
  begin: '%[qws]\<'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \>
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - name: constant.character.escape.onyx
    match: \\\>|\\\\
  - include: '#nest_ltgt'
- comment: literal incapable of interpolation -- []
  name: string.quoted.other.literal.lower.onyx
  begin: '%[qws]\['
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \]
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - name: constant.character.escape.onyx
    match: \\\]|\\\\
  - include: '#nest_brackets'
- comment: literal incapable of interpolation -- {}
  name: string.quoted.other.literal.lower.onyx
  begin: '%[qws]\{'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \}
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - name: constant.character.escape.onyx
    match: \\\}|\\\\
  - include: '#nest_curly'
- comment: literal incapable of interpolation -- wildcard
  name: string.quoted.other.literal.lower.onyx
  begin: '%[qws]([^\w])'
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \1
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - comment: Cant be named because its not neccesarily an escape.
    match: \\.
- comment: symbols
  name: constant.other.symbol.onyx
  match: (?<!:)(:)(?>[a-zA-Z_\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*(?>[?!]|=(?![>=]))?|===?|>[>=]?|<[<=]?|<=>|[%&`/\|]|\*\*?|=?~|[-+]@?|\[\]=?|@@?[a-zA-Z_\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*)
  captures:
    '1': {name: punctuation.definition.constant.onyx}
- comment: symbols
  name: constant.other.symbol.onyx.19syntax
  match: (?>[a-zA-Z_\x{80}-\x{10FFFF}][\w\x{80}-\x{10FFFF}]*(?>[?!])?)(:)(?!:)
  captures:
    '1': {name: punctuation.definition.constant.onyx}
- comment: multiline comments
  name: comment.block.documentation.onyx
  begin: ^=begin
  end: ^=end
  captures:
    '0': {name: punctuation.definition.comment.onyx}
- name: comment.line.number-sign.onyx
  match: (?:^[ \t]+)?(#).*$\n?
  captures:
    '1': {name: punctuation.definition.comment.onyx}
- comment: __END__ marker
  contentName: text.plain
  begin: ^__END__\n
  end: (?=not)impossible
  captures:
    '0': {name: string.unquoted.program-block.onyx}
  patterns:
  - name: text.html.embedded.onyx
    begin: (?=<?xml|<(?i:html\b)|!DOCTYPE (?i:html\b))
    end: (?=not)impossible
    patterns:
    - include: text.html.basic
- comment: heredoc with embedded HTML and indented terminator
  name: string.unquoted.embedded.html.onyx
  contentName: text.html.embedded.onyx
  begin: (?><<-("?)((?:[_\w]+_|)HTML)\b\1)
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\2$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: text.html.basic
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: heredoc with embedded SQL and indented terminator
  name: string.unquoted.embedded.sql.onyx
  contentName: text.sql.embedded.onyx
  begin: (?><<-("?)((?:[_\w]+_|)SQL)\b\1)
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\2$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: source.sql
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: heredoc with embedded css and intented terminator
  name: string.unquoted.embedded.css.onyx
  contentName: text.css.embedded.onyx
  begin: (?><<-("?)((?:[_\w]+_|)CSS)\b\1)
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\2$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: source.css
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: heredoc with embedded c++ and intented terminator
  name: string.unquoted.embedded.cplusplus.onyx
  contentName: text.c++.embedded.onyx
  begin: (?><<-("?)((?:[_\w]+_|)CPP)\b\1)
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\2$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: source.c++
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: heredoc with embedded c++ and intented terminator
  name: string.unquoted.embedded.c.onyx
  contentName: text.c.embedded.onyx
  begin: (?><<-("?)((?:[_\w]+_|)C)\b\1)
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\2$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: source.c
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: heredoc with embedded javascript and intented terminator
  name: string.unquoted.embedded.js.onyx
  contentName: text.js.embedded.onyx
  begin: (?><<-("?)((?:[_\w]+_|)(?:JS|JAVASCRIPT))\b\1)
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\2$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: source.js
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: heredoc with embedded javascript and intented terminator
  name: string.unquoted.embedded.js.jquery.onyx
  contentName: text.js.jquery.embedded.onyx
  begin: (?><<-("?)((?:[_\w]+_|)JQUERY)\b\1)
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\2$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: source.js.jquery
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: heredoc with embedded shell and intented terminator
  name: string.unquoted.embedded.shell.onyx
  contentName: text.shell.embedded.onyx
  begin: (?><<-("?)((?:[_\w]+_|)(?:SH|SHELL))\b\1)
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\2$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: source.shell
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: heredoc with embedded onyx and intented terminator
  name: string.unquoted.embedded.onyx.onyx
  contentName: text.onyx.embedded.onyx
  begin: (?><<-("?)((?:[_\w]+_|)RUBY)\b\1)
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\2$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: source.onyx
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- name: string.unquoted.heredoc.onyx
  begin: (?>\=\s*<<(\w+))
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: ^\1$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- comment: heredoc with indented terminator
  name: string.unquoted.heredoc.onyx
  begin: (?><<-(\w+))
  beginCaptures:
    '0': {name: punctuation.definition.string.begin.onyx}
  end: \s*\1$
  endCaptures:
    '0': {name: punctuation.definition.string.end.onyx}
  patterns:
  - include: '#heredoc'
  - include: '#interpolated_onyx'
  - include: '#escaped_char'
- begin: (?<=\{|do|\{\s|do\s)(\|)
  end: (\|)
  captures:
    '1': {name: punctuation.separator.variable.onyx}
  patterns:
  - name: variable.other.block.onyx
    match: '[_a-zA-Z][_a-zA-Z0-9]*'
  - name: punctuation.separator.variable.onyx
    match: ','
- name: punctuation.separator.key-value
  match: =>
- name: keyword.operator.assignment.augmented.onyx
  match: <<=|%=|&=|\*=|\*\*=|\+=|\-=|\^=|\|{1,2}=|<<
- name: keyword.operator.comparison.onyx
  match: <=>|<(?!<|=)|>(?!<|=|>)|<=|>=|===|==|=~|!=|!~|(?<=[ \t])\?
- name: keyword.operator.logical.onyx
  match: (?<=[ \t])!+|\bnot\b|&&|\band\b|\|\||\bor\b|\^
- name: keyword.operator.macro.onyx
  match: (\{\%|\%\}|\{\{|\}\})
- name: keyword.operator.arithmetic.onyx
  match: (%|&|\*\*|\*|\+|\-|/)
- name: keyword.operator.assignment.onyx
  match: '='
- name: keyword.operator.other.onyx
  match: \||~|>>
- name: punctuation.separator.other.onyx
  match: ':'
- name: punctuation.separator.statement.onyx
  match: \;
- name: punctuation.separator.object.onyx
  match: ','
- name: punctuation.separator.method.onyx
  match: '\.|::'
- name: punctuation.section.scope.onyx
  match: \{|\}
- name: punctuation.section.array.onyx
  match: \[|\]
- name: punctuation.section.function.onyx
  match: \(|\)
repository:
  escaped_char:
    name: constant.character.escape.onyx
    match: \\(?:[0-7]{1,3}|x[\da-fA-F]{1,2}|.)
  heredoc:
    begin: ^<<-?\w+
    end: $
    patterns:
    - include: $self
  interpolated_onyx:
    patterns:
    - name: source.onyx.embedded.source
      match: '#\{(\})'
      captures:
        '0': {name: punctuation.section.embedded.onyx}
        '1': {name: source.onyx.embedded.source.empty}
    - name: source.onyx.embedded.source
      begin: '#\{'
      end: \}
      captures:
        '0': {name: punctuation.section.embedded.onyx}
      patterns:
      - include: '#nest_curly_and_self'
      - include: $self
    - name: variable.other.readwrite.instance.onyx
      match: (#@)[a-zA-Z_]\w*
      captures:
        '1': {name: punctuation.definition.variable.onyx}
    - name: variable.other.readwrite.class.onyx
      match: (#@@)[a-zA-Z_]\w*
      captures:
        '1': {name: punctuation.definition.variable.onyx}
    - name: variable.other.readwrite.global.onyx
      match: (#\$)[a-zA-Z_]\w*
      captures:
        '1': {name: punctuation.definition.variable.onyx}
  nest_brackets:
    begin: \[
    end: \]
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#nest_brackets'
  nest_brackets_i:
    begin: \[
    end: \]
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#interpolated_onyx'
    - include: '#escaped_char'
    - include: '#nest_brackets_i'
  nest_brackets_r:
    begin: \[
    end: \]
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#regex_sub'
    - include: '#nest_brackets_r'
  nest_curly:
    begin: \{
    end: \}
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#nest_curly'
  nest_curly_and_self:
    patterns:
    - begin: \{
      end: \}
      captures:
        '0': {name: punctuation.section.scope.onyx}
      patterns:
      - include: '#nest_curly_and_self'
    - include: $self
  nest_curly_i:
    begin: \{
    end: \}
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#interpolated_onyx'
    - include: '#escaped_char'
    - include: '#nest_curly_i'
  nest_curly_r:
    begin: \{
    end: \}
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#regex_sub'
    - include: '#nest_curly_r'
  nest_ltgt:
    begin: \<
    end: \>
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#nest_ltgt'
  nest_ltgt_i:
    begin: \<
    end: \>
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#interpolated_onyx'
    - include: '#escaped_char'
    - include: '#nest_ltgt_i'
  nest_ltgt_r:
    begin: \<
    end: \>
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#regex_sub'
    - include: '#nest_ltgt_r'
  nest_parens:
    begin: \(
    end: \)
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#nest_parens'
  nest_parens_i:
    begin: \(
    end: \)
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#interpolated_onyx'
    - include: '#escaped_char'
    - include: '#nest_parens_i'
  nest_parens_r:
    begin: \(
    end: \)
    captures:
      '0': {name: punctuation.section.scope.onyx}
    patterns:
    - include: '#regex_sub'
    - include: '#nest_parens_r'
  regex_sub:
    patterns:
    - include: '#interpolated_onyx'
    - include: '#escaped_char'
    - name: string.regexp.arbitrary-repitition.onyx
      match: (\{)\d+(,\d+)?(\})
      captures:
        '1': {name: punctuation.definition.arbitrary-repitition.onyx}
        '3': {name: punctuation.definition.arbitrary-repitition.onyx}
    - name: string.regexp.character-class.onyx
      begin: \[(?:\^?\])?
      end: \]
      captures:
        '0': {name: punctuation.definition.character-class.onyx}
      patterns:
      - include: '#escaped_char'
    - name: string.regexp.group.onyx
      begin: \(
      end: \)
      captures:
        '0': {name: punctuation.definition.group.onyx}
      patterns:
      - include: '#regex_sub'
    - comment: We are restrictive in what we allow to go after the comment character
        to avoid false positives, since the availability of comments depend on regexp
        flags.
      name: comment.line.number-sign.onyx
      match: (?<=^|\s)(#)\s[[a-zA-Z0-9,. \t?!-][^\x{00}-\x{7F}]]*$
      captures:
        '1': {name: punctuation.definition.comment.onyx}
firstLineMatch: ^#!/.*\bonyx
foldingStartMarker: "(?x)^\n\t    (\\s*+\n\t        (module|class|def(?!.*\\bend\\\
  s*$)\n\t        |unless|if\n\t        |case\n\t        |begin\n\t        |for|while|until\n\
  \t         |^=begin\n\t        |(  \"(\\\\.|[^\"])*+\"          # eat a double quoted\
  \ string\n\t         | '(\\\\.|[^'])*+'        # eat a single quoted string\n\t\
  \         |   [^#\"']                # eat all but comments and strings\n\t    \
  \     )*\n\t         (                        \\s   (do|begin|case)\n\t        \
  \ | (?<!\\$)[-+=&|*/~%^<>~] \\s*+ (if|unless)\n\t         )\n\t        )\\b\n\t\
  \        (?! [^;]*+ ; .*? \\bend\\b )\n\t    |(  \"(\\\\.|[^\"])*+\"           \
  \   # eat a double quoted string\n\t     | '(\\\\.|[^'])*+'            # eat a single\
  \ quoted string\n\t     |   [^#\"']                    # eat all but comments and\
  \ strings\n\t     )*\n\t     ( \\{ (?!  [^}]*+ \\} )\n\t     | \\[ (?! [^\\]]*+\
  \ \\] )\n\t     )\n\t    ).*$\n\t|   [#] .*? \\(fold\\) \\s*+ $         # Sune\u2019\
  s special marker\n\t"
foldingStopMarker: "(?x)\n\t\t(   (^|;) \\s*+ end   \\s*+ ([#].*)? $\n\t\t|   (^|;)\
  \ \\s*+ end \\. .* $\n\t\t|   ^     \\s*+ [}\\]] ,? \\s*+ ([#].*)? $\n\t\t|   [#]\
  \ .*? \\(end\\) \\s*+ $    # Sune\u2019s special marker\n\t\t|   ^=end\n\t\t)"
keyEquivalent: ^~R
